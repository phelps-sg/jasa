<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_05) on Sat Sep 25 15:24:20 EDT 2004 -->
<TITLE>
GPNode
</TITLE>

<META NAME="keywords" CONTENT="ec.gp.GPNode class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="GPNode";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../ec/gp/GPInitializer.html" title="class in ec.gp"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../ec/gp/GPNodeBuilder.html" title="class in ec.gp"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GPNode.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
ec.gp</FONT>
<BR>
Class GPNode</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by"><B>ec.gp.GPNode</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.lang.Cloneable, <A HREF="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</A>, <A HREF="../../ec/Prototype.html" title="interface in ec">Prototype</A>, java.io.Serializable, <A HREF="../../ec/Setup.html" title="interface in ec">Setup</A></DD>
</DL>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../ec/gp/ADF.html" title="class in ec.gp">ADF</A>, <A HREF="../../ec/gp/ADFArgument.html" title="class in ec.gp">ADFArgument</A>, <A HREF="../../ec/gp/ERC.html" title="class in ec.gp">ERC</A></DD>
</DL>
<HR>
<DL>
<DT>public abstract class <B>GPNode</B><DT>extends java.lang.Object<DT>implements <A HREF="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</A></DL>

<P>
GPNode is a GPNodeParent which is the abstract superclass of
 all GP function nodes in trees.  GPNode contains quite a few functions
 for cloning subtrees in special ways, counting the number of nodes
 in subtrees in special ways, and finding specific nodes in subtrees.

 GPNode's protoClone() method does not clone its children (it copies the
 array, but that's it).  If you want to deep-clone a tree or subtree, you
 should use one of the cloneReplacing(...) methods instead.

 <p>GPNodes contain a number of important items:
 <ul><li>A <i>constraints</i> object which defines the name of the node,
 its arity, and its type constraints. This
 object is shared with all GPNodes of the same function name/arity/returntype/childtypes.
 <li>A <i>parent</i>.  This is either another GPNode, or (if this node
 is the root) a GPTree.
 <li>Zero or more <i>children</i>, which are GPNodes.
 <li>An argument position in its parent.
 </ul>

 <p><b>Parameters</b><br>
 <table>
 <tr><td valign=top><i>base</i>.<tt>nc</tt><br>
 <font size=-1>String</font></td>
 <td valign=top>(name of the node constraints for the GPNode)</td></tr>
 </table>

 <p><b>Default Base</b><br>
 gp.node
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../serialized-form.html#ec.gp.GPNode">Serialized Form</A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#argposition">argposition</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The argument position of the child in its parent.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#children">children</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#constraints">constraints</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The GPNode's constraints.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#GPNODEPRINTTAB">GPNODEPRINTTAB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#MAXPRINTBYTES">MAXPRINTBYTES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#NODESEARCH_ALL">NODESEARCH_ALL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#NODESEARCH_CUSTOM">NODESEARCH_CUSTOM</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#NODESEARCH_NONTERMINALS">NODESEARCH_NONTERMINALS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#NODESEARCH_TERMINALS">NODESEARCH_TERMINALS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#P_NODE">P_NODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#P_NODECONSTRAINTS">P_NODECONSTRAINTS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#parent">parent</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The GPNode's parent.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#REPLACEMENT_CHAR">REPLACEMENT_CHAR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#SITUATION_MUTATION">SITUATION_MUTATION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#SITUATION_NEWIND">SITUATION_NEWIND</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#GPNode()">GPNode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#atDepth()">atDepth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the depth at which I appear in the tree, which is a value >= 0.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#checkConstraints(ec.EvolutionState, int, ec.gp.GPIndividual, ec.util.Parameter)">checkConstraints</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                 int&nbsp;tree,
                 <A HREF="../../ec/gp/GPIndividual.html" title="class in ec.gp">GPIndividual</A>&nbsp;typicalIndividual,
                 <A HREF="../../ec/util/Parameter.html" title="class in ec.util">Parameter</A>&nbsp;individualBase)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;You ought to override this method to check to make sure that the
        constraints are valid as best you can tell.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacing()">cloneReplacing</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deep-clones the tree rooted at this node, and returns the entire
        copied tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacing(ec.gp.GPNode[], ec.gp.GPNode[])">cloneReplacing</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;newSubtrees,
               <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;oldSubtrees)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deep-clones the tree rooted at this node, and returns the entire
        copied tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacing(ec.gp.GPNode, ec.gp.GPNode)">cloneReplacing</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;newSubtree,
               <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;oldSubtree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deep-clones the tree rooted at this node, and returns the entire
        copied tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacingAtomic(ec.gp.GPNode[], ec.gp.GPNode[])">cloneReplacingAtomic</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;newNodes,
                     <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;oldNodes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clones a new subtree, but with each node in oldNodes[] respectively
        (which may or may not be in the subtree) replaced with
        the equivalent
        nodes in newNodes[] (and not clones).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacingAtomic(ec.gp.GPNode, ec.gp.GPNode)">cloneReplacingAtomic</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;newNode,
                     <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;oldNode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clones a new subtree, but with the single node oldNode 
        (which may or may not be in the subtree) 
        replaced with a newNode (not a clone of newNode).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacingAtomicSimple(ec.gp.GPNode[], ec.gp.GPNode[])">cloneReplacingAtomicSimple</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;newNodes,
                           <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;oldNodes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clones a new subtree, but with each node in oldNodes[] respectively
        (which may or may not be in the subtree) replaced with
        the equivalent
        nodes in newNodes[] (and not clones of them).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacingAtomicSimple(ec.gp.GPNode, ec.gp.GPNode)">cloneReplacingAtomicSimple</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;newNode,
                           <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;oldNode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clones a new subtree, but with the single node oldNode 
        (which may or may not be
        in the subtree) replaced with newNode (not a clone of newNode).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacingNoSubclone(ec.gp.GPNode, ec.gp.GPNode)">cloneReplacingNoSubclone</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;newSubtree,
                         <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;oldSubtree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deep-clones the tree rooted at this node, and returns the entire
        copied tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacingNoSubcloneSimple(ec.gp.GPNode, ec.gp.GPNode)">cloneReplacingNoSubcloneSimple</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;newSubtree,
                               <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;oldSubtree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deep-clones the tree rooted at this node, and returns the entire
        copied tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacingSimple()">cloneReplacingSimple</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deep-clones the tree rooted at this node, and returns the entire
        copied tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacingSimple(ec.gp.GPNode[], ec.gp.GPNode[])">cloneReplacingSimple</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;newSubtrees,
                     <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;oldSubtrees)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deep-clones the tree rooted at this node, and returns the entire
        copied tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacingSimple(ec.gp.GPNode, ec.gp.GPNode)">cloneReplacingSimple</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;newSubtree,
                     <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;oldSubtree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deep-clones the tree rooted at this node, and returns the entire
        copied tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNodeConstraints.html" title="class in ec.gp">GPNodeConstraints</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#constraints()">constraints</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#contains(ec.gp.GPNode)">contains</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;subnode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if the subtree rooted at this node contains subnode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/util/Parameter.html" title="class in ec.util">Parameter</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#defaultBase()">defaultBase</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The default base for GPNodes -- defined even though
        GPNode is abstract so you don't have to in subclasses.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#depth()">depth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the depth of the tree, which is a value >= 1.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#errorInfo()">errorInfo</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A convenience function for identifying a GPNode in an error message</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#eval(ec.EvolutionState, int, ec.gp.GPData, ec.gp.ADFStack, ec.gp.GPIndividual, ec.Problem)">eval</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
     int&nbsp;thread,
     <A HREF="../../ec/gp/GPData.html" title="class in ec.gp">GPData</A>&nbsp;input,
     <A HREF="../../ec/gp/ADFStack.html" title="class in ec.gp">ADFStack</A>&nbsp;stack,
     <A HREF="../../ec/gp/GPIndividual.html" title="class in ec.gp">GPIndividual</A>&nbsp;individual,
     <A HREF="../../ec/Problem.html" title="class in ec">Problem</A>&nbsp;problem)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evaluates the node with the given thread, state, individual, problem, and stack.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#makeLatexTree()">makeLatexTree</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Produces the LaTeX code for a LaTeX tree of the subtree rooted at this node, using the <tt>epic</tt>
        and <tt>fancybox</tt> packages, as described in sections 10.5.2 (page 307) 
        and 10.1.3 (page 278) of <i>The LaTeX Companion</i>, respectively.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#nodeEquals(ec.gp.GPNode)">nodeEquals</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if I am the "genetically" same as this node, and our
        children arrays are the same length, though
        we may have different parents and children.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#nodeHashCode()">nodeHashCode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a hashcode usually associated with all nodes that are 
        equal to you (using nodeEquals(...)).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#nodeInPosition(int, ec.gp.GPNodeGatherer, int)">nodeInPosition</A></B>(int&nbsp;p,
               <A HREF="../../ec/gp/GPNodeGatherer.html" title="class in ec.gp">GPNodeGatherer</A>&nbsp;g,
               int&nbsp;nodesearch)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the p'th node, constrained by nodesearch,
        in the subtree for which this GPNode is root.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#numNodes(ec.gp.GPNodeGatherer)">numNodes</A></B>(<A HREF="../../ec/gp/GPNodeGatherer.html" title="class in ec.gp">GPNodeGatherer</A>&nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of nodes, constrained by g.test(...)
        in the subtree for which this GPNode is root.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#numNodes(int)">numNodes</A></B>(int&nbsp;nodesearch)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of nodes, constrained by nodesearch,
        in the subtree for which this GPNode is root.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPType.html" title="class in ec.gp">GPType</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#parentType()">parentType</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the argument type of the slot that I fit into in my parent.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#printNode(ec.EvolutionState, int, int)">printNode</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
          int&nbsp;log,
          int&nbsp;verbosity)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints out a COMPUTER-readable and Lisp-like atom for the node, which
        is also suitable for readNode to read, and returns
        the number of bytes in the string that you sent to the log (use print(),
        not println()).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#printNode(ec.EvolutionState, java.io.PrintWriter)">printNode</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
          java.io.PrintWriter&nbsp;writer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints out a COMPUTER-readable and Lisp-like atom for the node, which
        is also suitable for readNode to read, and returns
        the number of bytes in the string that you sent to the log (use print(),
        not println()).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#printNodeForHumans(ec.EvolutionState, int, int)">printNodeForHumans</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                   int&nbsp;log,
                   int&nbsp;verbosity)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints out a human-readable and Lisp-like atom for the node, 
        and returns the number of bytes in the string that you sent
        to the log (use print(),
        not println()).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#printRootedTree(ec.EvolutionState, int, int, int)">printRootedTree</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                int&nbsp;log,
                int&nbsp;verbosity,
                int&nbsp;printbytes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints out the tree on a single line, with no ending \n, in a fashion that can
        be read in later by computer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#printRootedTree(ec.EvolutionState, java.io.PrintWriter, int)">printRootedTree</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                java.io.PrintWriter&nbsp;writer,
                int&nbsp;printbytes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints out the tree on a single line, with no ending \n, in a fashion that can
        be read in later by computer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#printRootedTreeForHumans(ec.EvolutionState, int, int, int, int)">printRootedTreeForHumans</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                         int&nbsp;log,
                         int&nbsp;verbosity,
                         int&nbsp;tablevel,
                         int&nbsp;printbytes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints out the tree in a readable Lisp-like multi-line fashion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#protoClone()">protoClone</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new individual cloned from a prototype,
        and suitable to begin use in its own evolutionary
        context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#protoCloneSimple()">protoCloneSimple</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This should be implemented in a the top-level Prototype ONLY;
        in fact, it should probably be declared final.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#readNode(ec.util.DecodeReturn)">readNode</A></B>(<A HREF="../../ec/util/DecodeReturn.html" title="class in ec.util">DecodeReturn</A>&nbsp;dret)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads the node symbol,
        advancing the DecodeReturn to the first character in the string
        beyond the node symbol, and returns a new, empty GPNode of the
        appropriate class representing that symbol, else null if the
        node symbol is not of the correct type for your GPNode class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#readRootedTree(int, ec.util.DecodeReturn, ec.gp.GPType, ec.gp.GPFunctionSet, ec.gp.GPNodeParent, int, ec.EvolutionState)">readRootedTree</A></B>(int&nbsp;linenumber,
               <A HREF="../../ec/util/DecodeReturn.html" title="class in ec.util">DecodeReturn</A>&nbsp;dret,
               <A HREF="../../ec/gp/GPType.html" title="class in ec.gp">GPType</A>&nbsp;expectedType,
               <A HREF="../../ec/gp/GPFunctionSet.html" title="class in ec.gp">GPFunctionSet</A>&nbsp;set,
               <A HREF="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</A>&nbsp;parent,
               int&nbsp;argposition,
               <A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads the node and its children from the form printed out by printRootedTree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#replaceWith(ec.gp.GPNode)">replaceWith</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;newNode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaces the node with another node in its position in the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#resetNode(ec.EvolutionState, int)">resetNode</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
          int&nbsp;thread)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Starts a node in a new life immediately after it has been cloned.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#rootedTreeEquals(ec.gp.GPNode)">rootedTreeEquals</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if the two rooted trees are "genetically" equal, though
        they may have different parents.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#rootedTreeHashCode()">rootedTreeHashCode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a hashcode associated with all the nodes in the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#rootParent()">rootParent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the root ancestor of this node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#setup(ec.EvolutionState, ec.util.Parameter)">setup</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
      <A HREF="../../ec/util/Parameter.html" title="class in ec.util">Parameter</A>&nbsp;base)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets up a <i>prototypical</i> GPNode with those features all nodes of that
        prototype share, and nothing more.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#swapCompatibleWith(ec.gp.GPNode)">swapCompatibleWith</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if I can swap into node's position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Lisp-like atom for the node which can be read in again by computer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#toStringForError()">toStringForError</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a description of the node that can make it easy to identify
        in error messages (by default, at least its name and the tree it's found in).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#toStringForHumans()">toStringForHumans</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Lisp-like atom for the node which is intended for human
        consumption, and not to be read in again.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="P_NODE"><!-- --></A><H3>
P_NODE</H3>
<PRE>
public static final java.lang.String <B>P_NODE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#ec.gp.GPNode.P_NODE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="P_NODECONSTRAINTS"><!-- --></A><H3>
P_NODECONSTRAINTS</H3>
<PRE>
public static final java.lang.String <B>P_NODECONSTRAINTS</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#ec.gp.GPNode.P_NODECONSTRAINTS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GPNODEPRINTTAB"><!-- --></A><H3>
GPNODEPRINTTAB</H3>
<PRE>
public static final java.lang.String <B>GPNODEPRINTTAB</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#ec.gp.GPNode.GPNODEPRINTTAB">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MAXPRINTBYTES"><!-- --></A><H3>
MAXPRINTBYTES</H3>
<PRE>
public static final int <B>MAXPRINTBYTES</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#ec.gp.GPNode.MAXPRINTBYTES">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="NODESEARCH_ALL"><!-- --></A><H3>
NODESEARCH_ALL</H3>
<PRE>
public static final int <B>NODESEARCH_ALL</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#ec.gp.GPNode.NODESEARCH_ALL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="NODESEARCH_TERMINALS"><!-- --></A><H3>
NODESEARCH_TERMINALS</H3>
<PRE>
public static final int <B>NODESEARCH_TERMINALS</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#ec.gp.GPNode.NODESEARCH_TERMINALS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="NODESEARCH_NONTERMINALS"><!-- --></A><H3>
NODESEARCH_NONTERMINALS</H3>
<PRE>
public static final int <B>NODESEARCH_NONTERMINALS</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#ec.gp.GPNode.NODESEARCH_NONTERMINALS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="NODESEARCH_CUSTOM"><!-- --></A><H3>
NODESEARCH_CUSTOM</H3>
<PRE>
public static final int <B>NODESEARCH_CUSTOM</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#ec.gp.GPNode.NODESEARCH_CUSTOM">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SITUATION_NEWIND"><!-- --></A><H3>
SITUATION_NEWIND</H3>
<PRE>
public static final int <B>SITUATION_NEWIND</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#ec.gp.GPNode.SITUATION_NEWIND">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SITUATION_MUTATION"><!-- --></A><H3>
SITUATION_MUTATION</H3>
<PRE>
public static final int <B>SITUATION_MUTATION</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#ec.gp.GPNode.SITUATION_MUTATION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="parent"><!-- --></A><H3>
parent</H3>
<PRE>
public <A HREF="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</A> <B>parent</B></PRE>
<DL>
<DD>The GPNode's parent.  4 bytes.  :-(  But it really helps simplify breeding.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="children"><!-- --></A><H3>
children</H3>
<PRE>
public <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[] <B>children</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="argposition"><!-- --></A><H3>
argposition</H3>
<PRE>
public byte <B>argposition</B></PRE>
<DL>
<DD>The argument position of the child in its parent. 
        This is a byte to save space (GPNode is the critical object space-wise) -- 
        besides, how often do you have 256 children? You can change this to a short
        or int easily if you absolutely need to.  It's possible to eliminate even
        this and have the child find itself in its parent, but that's an O(children[])
        operation, and probably not inlinable, so I figure a byte is okay.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="constraints"><!-- --></A><H3>
constraints</H3>
<PRE>
public byte <B>constraints</B></PRE>
<DL>
<DD>The GPNode's constraints.  This is a byte to save space -- how often do
        you have 256 different GPNodeConstraints?  Well, I guess it's not infeasible.
        You can increase4 this to an int without much trouble.  You typically 
        shouldn't access the constraints through this variable -- use the constraints()
        method instead.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="REPLACEMENT_CHAR"><!-- --></A><H3>
REPLACEMENT_CHAR</H3>
<PRE>
public static final char <B>REPLACEMENT_CHAR</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#ec.gp.GPNode.REPLACEMENT_CHAR">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="GPNode()"><!-- --></A><H3>
GPNode</H3>
<PRE>
public <B>GPNode</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="constraints()"><!-- --></A><H3>
constraints</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNodeConstraints.html" title="class in ec.gp">GPNodeConstraints</A> <B>constraints</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="defaultBase()"><!-- --></A><H3>
defaultBase</H3>
<PRE>
public <A HREF="../../ec/util/Parameter.html" title="class in ec.util">Parameter</A> <B>defaultBase</B>()</PRE>
<DL>
<DD>The default base for GPNodes -- defined even though
        GPNode is abstract so you don't have to in subclasses.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../ec/Prototype.html#defaultBase()">defaultBase</A></CODE> in interface <CODE><A HREF="../../ec/Prototype.html" title="interface in ec">Prototype</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="checkConstraints(ec.EvolutionState, int, ec.gp.GPIndividual, ec.util.Parameter)"><!-- --></A><H3>
checkConstraints</H3>
<PRE>
public void <B>checkConstraints</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                             int&nbsp;tree,
                             <A HREF="../../ec/gp/GPIndividual.html" title="class in ec.gp">GPIndividual</A>&nbsp;typicalIndividual,
                             <A HREF="../../ec/util/Parameter.html" title="class in ec.util">Parameter</A>&nbsp;individualBase)</PRE>
<DL>
<DD>You ought to override this method to check to make sure that the
        constraints are valid as best you can tell.  Things you might
        check for:

        <ul>
        <li> children.length is correct
        <li> certain arguments in constraints.childtypes are 
        swap-compatible with each other
        <li> constraints.returntype is swap-compatible with appropriate 
        arguments in constraints.childtypes
        </ul>

        You can't check for everything, of course, but you might try some
        obvious checks for blunders.  The default version of this method
        is empty for now, but you should still call super.checkConstraints(state)
        just to be certain.

        The ultimate caller of this method must guarantee that he will eventually
        call state.output.exitIfErrors(), so you can freely use state.output.error
        instead of state.output.fatal(), which will help a lot.

        Warning: this method may get called more than once.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setup(ec.EvolutionState, ec.util.Parameter)"><!-- --></A><H3>
setup</H3>
<PRE>
public void <B>setup</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                  <A HREF="../../ec/util/Parameter.html" title="class in ec.util">Parameter</A>&nbsp;base)</PRE>
<DL>
<DD>Sets up a <i>prototypical</i> GPNode with those features all nodes of that
        prototype share, and nothing more.  So no filled-in children, 
        no argposition, no parent.  Yet.

        This must be called <i>after</i> the GPTypes and GPNodeConstraints 
        have been set up.  Presently they're set up in GPInitializer,
        which gets called before this does, so we're safe. 

        You should override this if you need to load some special features on
        a per-function basis.  Note that base hangs off of a function set, so
        this method may get called for different instances in the same GPNode
        class if they're being set up as prototypes for different GPFunctionSets.

        If you absolutely need some global base, then you should use something
        hanging off of GPDefaults.base().

        The ultimate caller of this method must guarantee that he will eventually
        call state.output.exitIfErrors(), so you can freely use state.output.error
        instead of state.output.fatal(), which will help a lot.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../ec/Prototype.html#setup(ec.EvolutionState, ec.util.Parameter)">setup</A></CODE> in interface <CODE><A HREF="../../ec/Prototype.html" title="interface in ec">Prototype</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="parentType()"><!-- --></A><H3>
parentType</H3>
<PRE>
public final <A HREF="../../ec/gp/GPType.html" title="class in ec.gp">GPType</A> <B>parentType</B>()</PRE>
<DL>
<DD>Returns the argument type of the slot that I fit into in my parent.  
        If I'm the root, returns the treetype of the GPTree.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="swapCompatibleWith(ec.gp.GPNode)"><!-- --></A><H3>
swapCompatibleWith</H3>
<PRE>
public final boolean <B>swapCompatibleWith</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;node)</PRE>
<DL>
<DD>Returns true if I can swap into node's position.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="numNodes(ec.gp.GPNodeGatherer)"><!-- --></A><H3>
numNodes</H3>
<PRE>
public int <B>numNodes</B>(<A HREF="../../ec/gp/GPNodeGatherer.html" title="class in ec.gp">GPNodeGatherer</A>&nbsp;g)</PRE>
<DL>
<DD>Returns the number of nodes, constrained by g.test(...)
        in the subtree for which this GPNode is root.  This might
        be sped up by caching the value.  O(n).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="numNodes(int)"><!-- --></A><H3>
numNodes</H3>
<PRE>
public int <B>numNodes</B>(int&nbsp;nodesearch)</PRE>
<DL>
<DD>Returns the number of nodes, constrained by nodesearch,
        in the subtree for which this GPNode is root.
        This might be sped up by cacheing the value somehow.  O(n).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="depth()"><!-- --></A><H3>
depth</H3>
<PRE>
public int <B>depth</B>()</PRE>
<DL>
<DD>Returns the depth of the tree, which is a value >= 1.  O(n).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="atDepth()"><!-- --></A><H3>
atDepth</H3>
<PRE>
public int <B>atDepth</B>()</PRE>
<DL>
<DD>Returns the depth at which I appear in the tree, which is a value >= 0. O(ln n) avg.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="nodeInPosition(int, ec.gp.GPNodeGatherer, int)"><!-- --></A><H3>
nodeInPosition</H3>
<PRE>
public int <B>nodeInPosition</B>(int&nbsp;p,
                          <A HREF="../../ec/gp/GPNodeGatherer.html" title="class in ec.gp">GPNodeGatherer</A>&nbsp;g,
                          int&nbsp;nodesearch)</PRE>
<DL>
<DD>Returns the p'th node, constrained by nodesearch,
        in the subtree for which this GPNode is root.
        Use numNodes(nodesearch) to determine the total number.  Or if
        you used numNodes(g), then when
        nodesearch == NODESEARCH_CUSTOM, g.test(...) is used
        as the constraining predicate.
        p ranges from 0 to this number minus 1. O(n). The
        resultant node is returned in <i>g</i>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rootParent()"><!-- --></A><H3>
rootParent</H3>
<PRE>
public <A HREF="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</A> <B>rootParent</B>()</PRE>
<DL>
<DD>Returns the root ancestor of this node.  O(ln n) average case,
        O(n) worst case.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="contains(ec.gp.GPNode)"><!-- --></A><H3>
contains</H3>
<PRE>
public boolean <B>contains</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;subnode)</PRE>
<DL>
<DD>Returns true if the subtree rooted at this node contains subnode.  O(n).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="resetNode(ec.EvolutionState, int)"><!-- --></A><H3>
resetNode</H3>
<PRE>
public void <B>resetNode</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                      int&nbsp;thread)</PRE>
<DL>
<DD>Starts a node in a new life immediately after it has been cloned.
        The default version of this function does nothing.  The purpose of
        this function is to give ERCs a chance to set themselves to a new
        random value after they've been cloned from the prototype.
        You should not assume that the node is properly connected to other
        nodes in the tree at the point this method is called.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="errorInfo()"><!-- --></A><H3>
errorInfo</H3>
<PRE>
public java.lang.String <B>errorInfo</B>()</PRE>
<DL>
<DD>A convenience function for identifying a GPNode in an error message
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="protoClone()"><!-- --></A><H3>
protoClone</H3>
<PRE>
public java.lang.Object <B>protoClone</B>()
                            throws java.lang.CloneNotSupportedException</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../ec/Prototype.html" title="interface in ec">Prototype</A></CODE></B></DD>
<DD>Creates a new individual cloned from a prototype,
        and suitable to begin use in its own evolutionary
        context.

        <p>The question here is whether or not this means to perform a 
        "deep" or "light" ("shallow") clone, or something in-between.  
        You may need to deep-clone parts of your object
        rather than simply copying their references, depending
        on the situation:

        <p>
        <ul>
        <li>If you hold objects which are shared with other instances,
        don't clone them.
        <li>If you hold objects which must be unique, clone them.
        <li>If you hold objects which were given to you as a gesture
        of kindness, and aren't owned by you, you probably shouldn't clone
        them.
        <li> DON'T attempt to clone: Singletons, Cliques, or Groups.
        <li>Arrays are not cloned automatically; you may need to
        clone an array if you're not sharing it with other instances.
        Arrays have the nice feature of being copyable by calling clone()
        on them.
        </ul>

        <p><b>Implementations.</b>

        <ul>
        <li>If no ancestor of yours implements protoClone(),
        and you have no need to either (light cloning is fine with you),
        and you are abstract, then you should not declare protoClone().

        <li>If no ancestor of yours implements protoClone(),
        and you have no need to either (light cloning is fine with you),
        and you are <b>not</b> abstract, then you should implement
        it as follows:

        <p>
        <tt><pre>
        public Object protoClone() throws CloneNotSupportedException
        { 
        return super.clone();
        }
        </pre></tt>

        <li>If no ancestor of yours implements protoClone(), but you
        need to deep-clone some things, then you should implement it
        as follows:

        <p>
        <tt><pre>
        public Object protoClone() throws CloneNotSupportedException
        {
        myobj = (MyObject) (super.clone());

        // put your deep-cloning code here...
        // ...you should use protoClone and not 
        // protoCloneSimple to clone subordinate objects...
        return myobj;
        } 
        </pre></tt>

        <li>If you need to override an ancestors' implementation
        of protoClone, in order to do your own deep cloning as well,
        then you should implement it as follows:

        <p>
        <tt><pre>
        public Object protoClone() throws CloneNotSupportedException
        {
        MyObject myobj = (MyObject)(super.protoClone());

        // put your deep-cloning code here...
        // ...you should use protoClone and not 
        // protoCloneSimple to clone subordinate objects...
        return myobj;
        } 
        </pre></tt>

        </ul>

        <p>If you know that your superclasses will <i>never</i> change
        their protoClone() implementations, you might try inlining them
        in your overridden protoClone() method.  But this is dangerous
        (though it yields a small net increase).

        <p>In general, you want to keep your deep cloning to an absolute
        minimum, so that you don't have to call protoClone() but
        one time.

        <p>The approach taken here is the fastest that I am aware of
        while still permitting objects to be specified at runtime from
        a parameter file.  It would be faster to use the "new" operator;
        but that would require hard-coding that we can't do.  Although
        using java.lang.Object.clone() entails an extra layer that
        deals with stripping away the "protected" keyword and also 
        wrapping the exception handling (which is a BIG hit, about
        three times as slow as using "new"), it's still MUCH faster
        than using java.lang.Class.newInstance(), and also much faster
        than rolling our own Clone() method.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../ec/Prototype.html#protoClone()">protoClone</A></CODE> in interface <CODE><A HREF="../../ec/Prototype.html" title="interface in ec">Prototype</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.CloneNotSupportedException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="protoCloneSimple()"><!-- --></A><H3>
protoCloneSimple</H3>
<PRE>
public final java.lang.Object <B>protoCloneSimple</B>()</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../ec/Prototype.html" title="interface in ec">Prototype</A></CODE></B></DD>
<DD>This should be implemented in a the top-level Prototype ONLY;
        in fact, it should probably be declared final.  It should be
        implemented as follows:

        <p>
        <tt><pre>
        public final Object protoCloneSimple()
        {
        try { return protoClone(); }
        catch (CloneNotSupportedException e) 
        { throw new InternalError(); } // never happens
        } 
        </pre></tt>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../ec/Prototype.html#protoCloneSimple()">protoCloneSimple</A></CODE> in interface <CODE><A HREF="../../ec/Prototype.html" title="interface in ec">Prototype</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacing()"><!-- --></A><H3>
cloneReplacing</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>cloneReplacing</B>()
                            throws java.lang.CloneNotSupportedException</PRE>
<DL>
<DD>Deep-clones the tree rooted at this node, and returns the entire
        copied tree.  The result has everything set except for the root
        node's parent and argposition.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.CloneNotSupportedException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacingSimple()"><!-- --></A><H3>
cloneReplacingSimple</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>cloneReplacingSimple</B>()</PRE>
<DL>
<DD>Deep-clones the tree rooted at this node, and returns the entire
        copied tree. The result has everything set except for the root
        node's parent and argposition.
        Does not throw CloneNotSupportedException.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacing(ec.gp.GPNode, ec.gp.GPNode)"><!-- --></A><H3>
cloneReplacing</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>cloneReplacing</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;newSubtree,
                                   <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;oldSubtree)
                            throws java.lang.CloneNotSupportedException</PRE>
<DL>
<DD>Deep-clones the tree rooted at this node, and returns the entire
        copied tree.  If the node oldSubtree is located somewhere in this
        tree, then its subtree is replaced with a deep-cloned copy of
        newSubtree.  The result has everything set except for the root
        node's parent and argposition.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.CloneNotSupportedException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacingSimple(ec.gp.GPNode, ec.gp.GPNode)"><!-- --></A><H3>
cloneReplacingSimple</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>cloneReplacingSimple</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;newSubtree,
                                         <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;oldSubtree)</PRE>
<DL>
<DD>Deep-clones the tree rooted at this node, and returns the entire
        copied tree.  If the node oldSubtree is located somewhere in this
        tree, then its subtree is replaced with a deep-cloned copy of
        newSubtree.  The result has everything set except for the root
        node's parent and argposition. Does not throw
        CloneNotSupportedException.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacingNoSubclone(ec.gp.GPNode, ec.gp.GPNode)"><!-- --></A><H3>
cloneReplacingNoSubclone</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>cloneReplacingNoSubclone</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;newSubtree,
                                             <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;oldSubtree)
                                      throws java.lang.CloneNotSupportedException</PRE>
<DL>
<DD>Deep-clones the tree rooted at this node, and returns the entire
        copied tree.  If the node oldSubtree is located somewhere in this
        tree, then its subtree is replaced with
        newSubtree (<i>not</i> a copy of newSubtree).  
        The result has everything set except for the root
        node's parent and argposition.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.CloneNotSupportedException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacingNoSubcloneSimple(ec.gp.GPNode, ec.gp.GPNode)"><!-- --></A><H3>
cloneReplacingNoSubcloneSimple</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>cloneReplacingNoSubcloneSimple</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;newSubtree,
                                                   <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;oldSubtree)</PRE>
<DL>
<DD>Deep-clones the tree rooted at this node, and returns the entire
        copied tree.  If the node oldSubtree is located somewhere in this
        tree, then its subtree is replaced with
        newSubtree (<i>not</i> a copy of newSubtree).  
        The result has everything set except for the root
        node's parent and argposition. Does not throw
        CloneNotSupportedException.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacing(ec.gp.GPNode[], ec.gp.GPNode[])"><!-- --></A><H3>
cloneReplacing</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>cloneReplacing</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;newSubtrees,
                                   <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;oldSubtrees)
                            throws java.lang.CloneNotSupportedException</PRE>
<DL>
<DD>Deep-clones the tree rooted at this node, and returns the entire
        copied tree.  If a node in oldSubtrees is located somewhere in this
        tree, then its subtree is replaced with a deep-cloned copy of the
        subtree rooted at its equivalent number in 
        newSubtrees.  The result has everything set except for the root
        node's parent and argposition.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.CloneNotSupportedException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacingSimple(ec.gp.GPNode[], ec.gp.GPNode[])"><!-- --></A><H3>
cloneReplacingSimple</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>cloneReplacingSimple</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;newSubtrees,
                                         <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;oldSubtrees)</PRE>
<DL>
<DD>Deep-clones the tree rooted at this node, and returns the entire
        copied tree.  If a node in oldSubtrees is located somewhere in this
        tree, then its subtree is replaced with a deep-cloned copy of the
        subtree rooted at its equivalent number in 
        newSubtrees.  The result has everything set except for the root
        node's parent and argposition. Does not throw
        CloneNotSupportedException.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacingAtomic(ec.gp.GPNode, ec.gp.GPNode)"><!-- --></A><H3>
cloneReplacingAtomic</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>cloneReplacingAtomic</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;newNode,
                                         <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;oldNode)
                                  throws java.lang.CloneNotSupportedException</PRE>
<DL>
<DD>Clones a new subtree, but with the single node oldNode 
        (which may or may not be in the subtree) 
        replaced with a newNode (not a clone of newNode).  
        These nodes should be
        type-compatible both in argument and return types, and should have
        the same number of arguments obviously.  This function will <i>not</i>
        check for this, and if they are not the result is undefined.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.CloneNotSupportedException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacingAtomicSimple(ec.gp.GPNode, ec.gp.GPNode)"><!-- --></A><H3>
cloneReplacingAtomicSimple</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>cloneReplacingAtomicSimple</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;newNode,
                                               <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;oldNode)</PRE>
<DL>
<DD>Clones a new subtree, but with the single node oldNode 
        (which may or may not be
        in the subtree) replaced with newNode (not a clone of newNode).  
        These nodes should be
        type-compatible both in argument and return types, and should have
        the same number of arguments obviously.  This function will <i>not</i>
        check for this, and if they are not the result is undefined.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacingAtomic(ec.gp.GPNode[], ec.gp.GPNode[])"><!-- --></A><H3>
cloneReplacingAtomic</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>cloneReplacingAtomic</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;newNodes,
                                         <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;oldNodes)
                                  throws java.lang.CloneNotSupportedException</PRE>
<DL>
<DD>Clones a new subtree, but with each node in oldNodes[] respectively
        (which may or may not be in the subtree) replaced with
        the equivalent
        nodes in newNodes[] (and not clones).  
        The length of oldNodes[] and newNodes[] should
        be the same of course.  These nodes should be
        type-compatible both in argument and return types, and should have
        the same number of arguments obviously.  This function will <i>not</i>
        check for this, and if they are not the result is undefined.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.CloneNotSupportedException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacingAtomicSimple(ec.gp.GPNode[], ec.gp.GPNode[])"><!-- --></A><H3>
cloneReplacingAtomicSimple</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>cloneReplacingAtomicSimple</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;newNodes,
                                               <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;oldNodes)</PRE>
<DL>
<DD>Clones a new subtree, but with each node in oldNodes[] respectively
        (which may or may not be in the subtree) replaced with
        the equivalent
        nodes in newNodes[] (and not clones of them).  
        The length of oldNodes[] and newNodes[] should
        be the same of course.  These nodes should be
        type-compatible both in argument and return types, and should have
        the same number of arguments obviously.  This function will <i>not</i>
        check for this, and if they are not the result is undefined.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="replaceWith(ec.gp.GPNode)"><!-- --></A><H3>
replaceWith</H3>
<PRE>
public final void <B>replaceWith</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;newNode)</PRE>
<DL>
<DD>Replaces the node with another node in its position in the tree. 
        newNode should already have been cloned and ready to go.
        We presume that the other node is type-compatible and
        of the same arity (these things aren't checked).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="nodeHashCode()"><!-- --></A><H3>
nodeHashCode</H3>
<PRE>
public int <B>nodeHashCode</B>()</PRE>
<DL>
<DD>Returns a hashcode usually associated with all nodes that are 
        equal to you (using nodeEquals(...)).  The default form
        of this method returns the hashcode of the node's class.
        ERCs in particular probably will want to override this method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rootedTreeHashCode()"><!-- --></A><H3>
rootedTreeHashCode</H3>
<PRE>
public int <B>rootedTreeHashCode</B>()</PRE>
<DL>
<DD>Returns a hashcode associated with all the nodes in the tree.  
        The default version adds the hash of the node plus its child
        trees, rotated one-off each time, which seems reasonable.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="nodeEquals(ec.gp.GPNode)"><!-- --></A><H3>
nodeEquals</H3>
<PRE>
public boolean <B>nodeEquals</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;node)</PRE>
<DL>
<DD>Returns true if I am the "genetically" same as this node, and our
        children arrays are the same length, though
        we may have different parents and children.  The default form
        of this method does a class comparison.  You may need
        to override this to perform special comparisons, if you're
        an ERC, ADF, or ADM for example.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rootedTreeEquals(ec.gp.GPNode)"><!-- --></A><H3>
rootedTreeEquals</H3>
<PRE>
public boolean <B>rootedTreeEquals</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;node)</PRE>
<DL>
<DD>Returns true if the two rooted trees are "genetically" equal, though
        they may have different parents.  O(n).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printNodeForHumans(ec.EvolutionState, int, int)"><!-- --></A><H3>
printNodeForHumans</H3>
<PRE>
public int <B>printNodeForHumans</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                              int&nbsp;log,
                              int&nbsp;verbosity)</PRE>
<DL>
<DD>Prints out a human-readable and Lisp-like atom for the node, 
        and returns the number of bytes in the string that you sent
        to the log (use print(),
        not println()).  The default version gets the atom from
        toStringForHumans().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printNode(ec.EvolutionState, int, int)"><!-- --></A><H3>
printNode</H3>
<PRE>
public int <B>printNode</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                     int&nbsp;log,
                     int&nbsp;verbosity)</PRE>
<DL>
<DD>Prints out a COMPUTER-readable and Lisp-like atom for the node, which
        is also suitable for readNode to read, and returns
        the number of bytes in the string that you sent to the log (use print(),
        not println()).  The default version gets the atom from toString().
        O(1).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printNode(ec.EvolutionState, java.io.PrintWriter)"><!-- --></A><H3>
printNode</H3>
<PRE>
public int <B>printNode</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                     java.io.PrintWriter&nbsp;writer)</PRE>
<DL>
<DD>Prints out a COMPUTER-readable and Lisp-like atom for the node, which
        is also suitable for readNode to read, and returns
        the number of bytes in the string that you sent to the log (use print(),
        not println()).  The default version gets the atom from toString().
        O(1).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public abstract java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>Returns a Lisp-like atom for the node which can be read in again by computer.
        If you need to encode an integer or a float or whatever for some reason
        (perhaps if it's an ERC), you should use the ec.util.Code library.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toStringForHumans()"><!-- --></A><H3>
toStringForHumans</H3>
<PRE>
public java.lang.String <B>toStringForHumans</B>()</PRE>
<DL>
<DD>Returns a Lisp-like atom for the node which is intended for human
        consumption, and not to be read in again.  The default version
        just calls toString().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toStringForError()"><!-- --></A><H3>
toStringForError</H3>
<PRE>
public java.lang.String <B>toStringForError</B>()</PRE>
<DL>
<DD>Returns a description of the node that can make it easy to identify
        in error messages (by default, at least its name and the tree it's found in).
        It's okay if this is a reasonably expensive procedure -- it won't be called
        a lot.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="makeLatexTree()"><!-- --></A><H3>
makeLatexTree</H3>
<PRE>
public java.lang.String <B>makeLatexTree</B>()</PRE>
<DL>
<DD>Produces the LaTeX code for a LaTeX tree of the subtree rooted at this node, using the <tt>epic</tt>
        and <tt>fancybox</tt> packages, as described in sections 10.5.2 (page 307) 
        and 10.1.3 (page 278) of <i>The LaTeX Companion</i>, respectively.  For this to
        work, the output of toString() must not contain any weird latex characters, notably { or } or % or \,
        unless you know what you're doing. See the documentation for ec.gp.GPTree for information
        on how to take this code snippet and insert it into your LaTeX file.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printRootedTree(ec.EvolutionState, int, int, int)"><!-- --></A><H3>
printRootedTree</H3>
<PRE>
public int <B>printRootedTree</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                           int&nbsp;log,
                           int&nbsp;verbosity,
                           int&nbsp;printbytes)</PRE>
<DL>
<DD>Prints out the tree on a single line, with no ending \n, in a fashion that can
        be read in later by computer. O(n).  
        You should call this method with printbytes == 0.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printRootedTree(ec.EvolutionState, java.io.PrintWriter, int)"><!-- --></A><H3>
printRootedTree</H3>
<PRE>
public int <B>printRootedTree</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                           java.io.PrintWriter&nbsp;writer,
                           int&nbsp;printbytes)</PRE>
<DL>
<DD>Prints out the tree on a single line, with no ending \n, in a fashion that can
        be read in later by computer. O(n).  Returns the number of bytes printed.
        You should call this method with printbytes == 0.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printRootedTreeForHumans(ec.EvolutionState, int, int, int, int)"><!-- --></A><H3>
printRootedTreeForHumans</H3>
<PRE>
public int <B>printRootedTreeForHumans</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                                    int&nbsp;log,
                                    int&nbsp;verbosity,
                                    int&nbsp;tablevel,
                                    int&nbsp;printbytes)</PRE>
<DL>
<DD>Prints out the tree in a readable Lisp-like multi-line fashion. O(n).  You should call this method with tablevel and printbytes == 0.  No ending '\n' is printed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="readNode(ec.util.DecodeReturn)"><!-- --></A><H3>
readNode</H3>
<PRE>
public <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>readNode</B>(<A HREF="../../ec/util/DecodeReturn.html" title="class in ec.util">DecodeReturn</A>&nbsp;dret)
                throws java.lang.CloneNotSupportedException</PRE>
<DL>
<DD>Reads the node symbol,
        advancing the DecodeReturn to the first character in the string
        beyond the node symbol, and returns a new, empty GPNode of the
        appropriate class representing that symbol, else null if the
        node symbol is not of the correct type for your GPNode class. You may
        assume that initial whitespace has been eliminated.  Generally should
        be case-SENSITIVE, unlike in Lisp.  The default
        version usually works for "simple" function names, that is, not ERCs
        or other stuff where you have to encode the symbol.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.CloneNotSupportedException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="readRootedTree(int, ec.util.DecodeReturn, ec.gp.GPType, ec.gp.GPFunctionSet, ec.gp.GPNodeParent, int, ec.EvolutionState)"><!-- --></A><H3>
readRootedTree</H3>
<PRE>
public static <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>readRootedTree</B>(int&nbsp;linenumber,
                                    <A HREF="../../ec/util/DecodeReturn.html" title="class in ec.util">DecodeReturn</A>&nbsp;dret,
                                    <A HREF="../../ec/gp/GPType.html" title="class in ec.gp">GPType</A>&nbsp;expectedType,
                                    <A HREF="../../ec/gp/GPFunctionSet.html" title="class in ec.gp">GPFunctionSet</A>&nbsp;set,
                                    <A HREF="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</A>&nbsp;parent,
                                    int&nbsp;argposition,
                                    <A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state)
                             throws java.lang.CloneNotSupportedException</PRE>
<DL>
<DD>Reads the node and its children from the form printed out by printRootedTree.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.CloneNotSupportedException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="eval(ec.EvolutionState, int, ec.gp.GPData, ec.gp.ADFStack, ec.gp.GPIndividual, ec.Problem)"><!-- --></A><H3>
eval</H3>
<PRE>
public abstract void <B>eval</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                          int&nbsp;thread,
                          <A HREF="../../ec/gp/GPData.html" title="class in ec.gp">GPData</A>&nbsp;input,
                          <A HREF="../../ec/gp/ADFStack.html" title="class in ec.gp">ADFStack</A>&nbsp;stack,
                          <A HREF="../../ec/gp/GPIndividual.html" title="class in ec.gp">GPIndividual</A>&nbsp;individual,
                          <A HREF="../../ec/Problem.html" title="class in ec">Problem</A>&nbsp;problem)</PRE>
<DL>
<DD>Evaluates the node with the given thread, state, individual, problem, and stack.
        Your random number generator will be state.random[thread].  
        The node should, as appropriate, evaluate child nodes with these same items
        passed to eval(...).

        <p>About <b>input</b>: <tt>input</tt> is special; it is how data is passed between
        parent and child nodes.  If children "receive" data from their parent node when
        it evaluates them, they should receive this data stored in <tt>input</tt>.
        If (more likely) the parent "receives" results from its children, it should
        pass them an <tt>input</tt> object, which they'll fill out, then it should
        check this object for the returned value.

        <p>A tree is typically evaluated by dropping a GPData into the root.  When the
        root returns, the resultant <tt>input</tt> should hold the return value.

        <p>In general, you should not be creating new GPDatas.  
        If you think about it, in most conditions (excepting ADFs and ADMs) you 
        can use and reuse <tt>input</tt> for most communications purposes between
        parents and children.  

        <p>So, let's say that your GPNode function implements the boolean AND function,
        and expects its children to return return boolean values (as it does itself).
        You've implemented your GPData subclass to be, uh, <b>BooleanData</b>, which
        looks like 

 <tt><pre>public class BooleanData extends GPData 
    {
    public boolean result;
    public GPData copyTo(GPData gpd)
      {
      ((BooleanData)gpd).result = result;
      }
    }</pre></tt>

        <p>...so, you might implement your eval(...) function as follows:

 <tt><pre>public void eval(final EvolutionState state,
                     final int thread,
                     final GPData input,
                     final ADFStack stack,
                     final GPIndividual individual,
                     final Problem problem
    {
    BooleanData dat = (BooleanData)input;
    boolean x;

    // evaluate the first child
    children[0].eval(state,thread,input,stack,individual,problem);
  
    // store away its result
    x = dat.result;

    // evaluate the second child
    children[1].eval(state,thread,input,stack,individual,problem);

    // return (in input) the result of the two ANDed

    dat.result = dat.result && x;
    return;
    }
        </pre></tt>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../ec/gp/GPInitializer.html" title="class in ec.gp"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../ec/gp/GPNodeBuilder.html" title="class in ec.gp"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GPNode.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
